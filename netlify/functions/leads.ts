import { HandlerEvent, HandlerContext, HandlerResponse } from './utils/api-utils';
import neo4j from 'neo4j-driver';
import {
  corsHeaders,
  createResponse,
  successResponse,
  errorResponse,
  handleCors,
  parseBody,
  validateRequiredFields,
  extractIdFromPath,
  authenticateRequest,
  logRequest,
} from './utils/api-utils';
import { validateRequestSize } from './utils/size-validator';
import { withUnifiedDatabase, unifiedDatabase } from './utils/unified-db';

// Lead API Handler - without size validation
const leadsHandler = async (
  event: HandlerEvent,
  context: HandlerContext
): Promise<HandlerResponse> => {
  logRequest(event, context);

  // Handle CORS preflight requests
  if (event.httpMethod === 'OPTIONS') {
    return handleCors();
  }

  // Basic authentication check
  if (!authenticateRequest(event)) {
    return errorResponse(401, 'Unauthorized');
  }

  try {
    const leadId = extractIdFromPath(event.path);

    switch (event.httpMethod) {
      case 'GET':
        return await handleGetLeads(leadId);
      
      case 'POST':
        return await handleCreateLead(event);
      
      case 'PUT':
        if (!leadId) {
          return errorResponse(400, 'Lead ID is required for updates');
        }
        return await handleUpdateLead(leadId, event);
      
      case 'DELETE':
        if (!leadId) {
          return errorResponse(400, 'Lead ID is required for deletion');
        }
        return await handleDeleteLead(leadId);
      
      default:
        return errorResponse(405, 'Method not allowed');
    }
  } catch (error) {
    console.error('Leads API error:', error);
    return errorResponse(500, 'Internal server error');
  }
};

// Initialize Neo4j Driver
const initNeo4j = () => {
  const neo4jUri = process.env.NEO4J_URI;
  if (!neo4jUri) {
    throw new Error('NEO4J_URI environment variable is not set.');
  }

  const driver = neo4j.driver(
    neo4jUri,
    neo4j.auth.basic(
      process.env.NEO4J_USERNAME || 'neo4j',
      process.env.NEO4J_PASSWORD || 'password'
    )
  );
  return driver;
};

const driver = initNeo4j();

// Get leads (all or specific lead)
const handleGetLeads = async (leadId?: string | null): Promise<HandlerResponse> => {
  try {
    return await withUnifiedDatabase(async () => {
      if (leadId) {
        // Get specific lead
        const lead = await unifiedDatabase.lead.findById(leadId);
        
        if (!lead) {
          return errorResponse(404, 'Lead not found');
        }
        
        return successResponse(lead);
      } else {
        // Get all leads
        const leads = await unifiedDatabase.lead.findMany();
        return successResponse(leads);
      }
    });
  } catch (error) {
    console.error('Error getting leads:', error);
    return errorResponse(500, 'Error getting leads');
  }
};

// Create new lead
const handleCreateLead = async (event: HandlerEvent): Promise<HandlerResponse> => {
  const body = parseBody(event);

  if (!body) {
    return errorResponse(400, 'Request body is required');
  }

  const missingFields = validateRequiredFields(body, ['name', 'email']);
  if (missingFields.length > 0) {
    return errorResponse(400, `Missing required fields: ${missingFields.join(', ')}`);
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(body.email)) {
    return errorResponse(400, 'Invalid email format');
  }

  // Prepare lead data (ID will be generated by the database layer)
  const leadData = {
    name: body.name,
    email: body.email,
    phone: body.phone || null,
    company: body.company || null,
    status: body.status || 'NEW',
    assignedTo: body.assignedTo || null,
  };
  try {
    return await withUnifiedDatabase(async () => {
      // Create the lead with unified database
      const lead = await unifiedDatabase.lead.create(leadData);
      return successResponse(lead, 'Lead created successfully');
    });
  } catch (error) {
    console.error('Error creating lead:', error);
    return errorResponse(500, 'Error creating lead');
  }
};

// Update lead
const handleUpdateLead = async (leadId: string, event: HandlerEvent): Promise<HandlerResponse> => {
  const body = parseBody(event);

  if (!body) {
    return errorResponse(400, 'Request body is required');
  }

  // Validate email format if provided
  if (body.email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(body.email)) {
      return errorResponse(400, 'Invalid email format');
    }
  }
  try {
    return await withUnifiedDatabase(async () => {
      // Check if lead exists
      const existingLead = await unifiedDatabase.lead.findById(leadId);
      
      if (!existingLead) {
        return errorResponse(404, 'Lead not found');
      }
      
      // Update fields
      const updateData = {
        ...(body.name !== undefined && { name: body.name }),
        ...(body.email !== undefined && { email: body.email }),
        ...(body.phone !== undefined && { phone: body.phone }),
        ...(body.company !== undefined && { company: body.company }),
        ...(body.status !== undefined && { status: body.status }),
        ...(body.assignedTo !== undefined && { assignedTo: body.assignedTo }),
      };
      
      const updatedLead = await unifiedDatabase.lead.update(leadId, updateData);
      return successResponse(updatedLead, 'Lead updated successfully');
    });
  } catch (error) {
    console.error('Error updating lead:', error);
    return errorResponse(500, 'Error updating lead');
  }
};

// Delete lead
const handleDeleteLead = async (leadId: string): Promise<HandlerResponse> => {  try {
    // Use unified database with fallback mechanism
    return await withUnifiedDatabase(async () => {
      // Check if lead exists
      const lead = await unifiedDatabase.lead.findById(leadId);
      
      if (!lead) {
        return errorResponse(404, 'Lead not found');
      }
      
      await unifiedDatabase.lead.delete(leadId);
      return successResponse(null, 'Lead deleted successfully');
    });
  } catch (error) {
    console.error('Error deleting lead:', error);
    return errorResponse(500, 'Error deleting lead');
  }
};

// Apply size validation middleware to the handler
export const handler = validateRequestSize(leadsHandler);